1.常见的垃圾收集器有哪些？
Serial GC：最古老的垃圾收集器，工作是单线程，在垃圾收集的过程中可能进入“Stop-The-World”状态。设计简单，一直是client模式下jvm的默认垃圾收集器。新生代采用的是复制算法，导致stop-the-world。通常将其老年代的实现单独称作为Serial Old，从年代角度讲他实现了 标记-整理算法
对应的jvm参数是：-XX：+UseSerialGC

PartNew GC：新生代算法，实际上是Serial GC的多线程版本，基于复制算法，一般配合老年代的CMS GC法使用
对应的jvm参数：-XX:+UseConcMarkSweepGC --XX:+UseParNewGC

CMS(concurrent Mark Sweep) GC:基于标记-清除算法（Mark-Sweep），设计目标是尽量减少停顿时间，但是CMS存在内存碎片化的问题，长时间运行会发生full GC问题，导致恶劣的停顿，CMS是并发的（与工作线程一起并发运行），占用更多的CPU资源，并和用户线程争抢


Parrallel GC：在jdk8及之前的默认server模式下GC选择，被称为吞吐量优先GC，其特点是新生代和老年代GC并发进行的，在常见的服务器环境中更加高效。实现算法和serial类似，但是更加复杂
对应的jvm参数：-XX:+UseParrallelGC


G1 GC:这是一种兼顾吞吐量和停顿时间的GC实现，jdk9的默认GC选项。相比于CMS，G1在CMS最好的情况下停顿时间不一定更好，但是要比CMS最差情况好。G1在新生代采用的是复制算法，还是有可能产生stop-the-world问题，老年代采用的是标记-整理算法。G1整体可以看成是标记-整理算法，可以有效的避免内存碎片化，尤其是Java堆很大的时候，G1优势更明显


2.怎么判断对象是否可以回收？
引用计数算法：循环引用的问题很难解决

可达性分析

3.常见的垃圾收集算法
1.复制算法：预留内存进行复制，内存占用比较大
2.标记-清除（Mark-Sweep）算法：先进行标记，在进行删除。标记，清除过程效率优先，无法避免内存碎片化的问题，导致其不适用特别大的堆，否则一旦出现full GC，暂停时间无法接受
3.标记-整理（Mark-Compact）算法：类似标记-清除，但为了避免内存碎片化，它会在清理的过程中将对象移动位置，以确保占用连续内存。

4.GC过程详细分析（通用GC）
Java应用创建对象一般分配在eden上，达到一定的阈值会触发minor GC，活下来的会被复制到survivor区（from）；当eden区再次达到阈值，触发minor GC，eden区存活下来的对象和from区中的会被复制到to，对象存活年龄+1；类似上一步多次重复，达到规定值晋升到老年代。
这个规定值可以通过参数指定 -XX:MaxTenuringThreshold=<N>

接下来就是老年代的GC，取决于具体的算法，通常把老年代GC成为Major GC，将对整个堆的清理操作成为Full GC。
不同老年代的GC算法表现差异其实很大。

5.调优思路
所谓的调优是针对特定的场景和目的的事。对于GC调优来说从性能方面讲一般关注三个方面：内存占用，延时和吞吐量。
一般我们调优只针对于其中的一两个方面，很少情况可以兼三个方面.具体问题具体分析，GC收集器的选择



