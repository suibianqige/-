1.堆内存划分
新生代  老年代  永久带

新生代：一个eden，两个survivor区（form，to）；gc过程中将eden中存活下来的对象和from区的对象拷贝到to区域，这种设计为了防止内存碎片化。进一步清理无用对象。

eden是新生对象的默认分配位置。eden也细分为Thread Local Allocation Buffer（TLAB）,每个线程的私有缓存区域，这样多线程同时分配内存是可以避免操作同一地址，这样就可能要使用加锁机制，进而影响分配速度。

老年代：老年代的对象一般都是从survivor区拷贝过来的对象，也有特例。对象一般会被分配在TLAB上，如果对象比较大，jvm会试图直接分配在eden上；如果太大，在新生区无法找到足够大的连续存储空间，就会直接分配到老年代。

永久代：jvm方法区的实现方式，存储Java类的元数据，常量池，intern字符串缓存。

2.参数配置
-Xmx value 最大堆内存
-Xms value 最小堆内存
-XX:NewRatio=value(老年代和新生代比例，默认是2，老年代占2/3)
-XX:NewSize=value 新生代内存大小 
-XX:SurvivorRatio=value 两个survivor区和eden区比例 一般是8，代表两个survivor各占1/10，eden占8/10

3：jvm监控工具 JConsole，VisualVM

5.happen-before是什么？
由于存在线程本地内存和主内存的原因，再加上重排序（编译器的优化，现代处理器的乱序执行），会导致多线程环境下存在可见性的问题
Happen-before保证多线程环境下的可见性
程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；
volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；

具体实现happen-before原则依靠的是内存屏障。分为读屏障，写屏障。强迫处理器缓存失效，从主存读取最新值