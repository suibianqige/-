### 1.数据库的事物的四要素（ACID）

原子性 一致性 隔离性 持久性

原子性：一个事物要么都完成要么都不完成

一致性：一般是从业务层面上讲一致性：比如银行转账问题，就是一致性的最好说明

隔离性：事物之间不能相互影响

持久性： 事物操作要可以持久化



### 2.数据库事物操作产生的集中数据问题

脏读  不可重复读  幻读

脏读是指 当前事物读取了其他事物未提交的事物（读了其他事物提交之前的数据）

不可重复读指 两次读取的数据不一样（其他事物并发修改数据 只针对update/delete操作）

幻读指 两次读的数据不一样（其他数据并发修改，指针对delete操作）

### 3.Mysql的数据库隔离级别

读未提交 ：未解决任何事物问题
读已提交 ：解决脏读问题
可重复读 ：解决不可重复读问题（未指明可以解决幻读，其实mysql是可以解决的）
串行化 ：串行化，没有并发度


### 4.Mysql的锁类型：共享锁（行锁） ，排它锁（行锁） ， 意向共享锁（表锁） ，意向排它锁（表锁）

共享锁：只能读，多个事物可以同时持有锁（但是只能读,仅对于这一行数据而言）
select * from table where id = 1 LOCK IN SHARE MODE;
此时 delete from table where id = 1 这条语句同时执行会被阻塞，所以在获取共享锁之后切记不要做修改，否则很容易造成思索问题。

排它锁：一个事物获取了这行数据的锁，其他事物就不能再次获取（无论是共享还是排它锁）
自动获取排它锁：insert/update/delete 操作会自动加一把排它锁；
手动获取：select * from table where id = 1 FOR UPDATE;

当前事物获取排它锁之后，其他的事物对这行数据的操作都会被阻塞；

释放锁有两种方式：回滚（roolBack）或者提交事物（commit）

意向锁：意向锁是表级别的锁，由InneDB引擎维护，用户无法操作，
当用户加上了一个共享锁，那么这张表上一定会有一个共享意向锁；
当用户加上了一个排他锁，那么这张表上一定会有一个排他意向锁；
反过来说也成立：有意向锁，可定有某行数据加上对应的锁了

之所以有行锁了还有锁表是为了优化后续的事物获取锁：

如果后续有事物想要锁整张表，那么前提是这张表不能有任何一条数据带锁，就需要全表扫描，效率太低。有了表锁就可以直接判断是否可以加表锁

### 5.索引对表的影响（mysql的锁是基于索引的）

1.没有任何索引，排它锁会锁住整张表，修改其他行会被阻塞，也无法查询 （Inndb创建默认索引，全部锁定）
2.主键索引 ： 锁住的是当前的行
3.唯一索引 和 主键索引： 锁住的是同一个 


